// The token package implements an all-or-nothing-transformed signature scheme.
// 
// Generating keys:
//   - Keys are generated by drawing 128 bytes of entropy from the system
//     entropy source, and hashing them to generate a seed
//   - This seed is stored, as a proof that the key was not generated
//     maliciously.
//
// Signing:
//   - Form signature using djb's Ed25519 variant of EC-Schnorr
//   - AONT public_key||message||signature||0x00000000
//   - Return the suffix of the AONT, not including the public key
//
// Verifying:
//   - 
package token

import (
	_ "crypto/aes"
	"crypto/rand"
	"io"

	_ "github.com/agl/ed25519"
	_ "golang.org/x/crypto/sha3"
)

type PublicKey struct {
	pub [ed25519.PublicKeySize]byte
	sym [32]byte
}

type PrivateKey struct {
	PublicKey
	seed []byte
	priv [ed25519.PrivateKeySize]byte
}

func (k *PrivateKey) Issue(p []byte) (c []byte) {
	ht := sha3.ShakeSum256(p, 128+8)
	sig := ed25519.Sign(k.priv, p)
	c := make([]byte, len(p) + 128+8)
	block, _ := aes.NewCipher(k.sym)

}

func NewPrivateKey() (priv *PrivateKey, err error) {
	priv = &PrivateKey{}
	buf := make([]byte, 128)
	_, err := io.ReadFull(rand.Reader, buf)
	priv.seed = sha3.Sum512(buf)[:32]

	inbuf := buffer.NewBuffer(sha3.Sum512(priv.seed)[:32])
	s.pub, s.priv, err := ed25519.GenerateKey(inbuf)
	if err != nil {
		priv = nil
		return
	}
	s.sym := sha3.Sum512(s.pub[:])[:32]
	return
}

